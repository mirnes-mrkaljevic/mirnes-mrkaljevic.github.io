[
  
    {
      "title": "Understanding State Machines with a Practical Example  in C#",
      "url": "/understanding-state-machines-with-a-practical-example-in-csharp",
      "date": "2025-04-21",
      "tags": "cleancode, csharp, designpatterns, statemachine",
      "content": "State machines might sound like a complex topic, but at their core, they’re just a way to manage different states in a system and control how things transition from one state to another.In this post, we’ll break down what state machines are, why they’re useful, and how to implement one in C# using a straightforward approach. We’ll also walk through a real-world example to see them in action.What is a State Machine?A state machine is a pattern used to control the flow of a system by defining possible states and the rules that determine how transitions between those states happen. It consists of:      States : Different conditions or modes the system can be in.        Transitions : Rules that define how the system moves from one state to another.        Events : Triggers that cause state transitions.        Actions : Operations performed when entering, exiting, or staying in a state.  Why Use a State Machine?State machines provide several benefits when managing workflows:      Improved Readability : Helps organize complex logic in an understandable way.        Encapsulation of State Logic : Keeps state-specific behavior separate from other business logic.        Predictability and Maintainability : Makes it easier to track and debug state changes.        Flexibility : New states and transitions can be added without major changes.  Implementing a State Machine in C#Let’s implement a simple state machine using a dictionary to manage state transitions.Use Case: Order Processing SystemImagine you’re building an e-commerce application that handles order statuses. An order can go through several states before completion.States and Transitions      States : PendingPayment, Processing, Shipped, Delivered, Cancelled        Events :          Pay (moves from PendingPayment to Processing)      Ship (moves from Processing to Shipped)      Deliver (moves from Shipped to Delivered)      Cancel (moves from PendingPayment to Cancelled or from Processing to Cancelled)      C# Implementation  State Machine Logic :using System;using System.Collections.Generic;class OrderStateMachine{    public enum OrderState { PendingPayment, Processing, Shipped, Delivered, Cancelled }    public enum OrderTrigger { Pay, Ship, Deliver, Cancel }    private Dictionary&lt;(OrderState, OrderTrigger), OrderState&gt; _stateTransitions;    public OrderState CurrentState { get; private set; }    public OrderStateMachine()    {        CurrentState = OrderState.PendingPayment;        _stateTransitions = new Dictionary&lt;(OrderState, OrderTrigger), OrderState&gt;        {            { (OrderState.PendingPayment, OrderTrigger.Pay), OrderState.Processing },            { (OrderState.PendingPayment, OrderTrigger.Cancel), OrderState.Cancelled },            { (OrderState.Processing, OrderTrigger.Ship), OrderState.Shipped },            { (OrderState.Processing, OrderTrigger.Cancel), OrderState.Cancelled },            { (OrderState.Shipped, OrderTrigger.Deliver), OrderState.Delivered }        };    }    public void ProcessTransition(OrderTrigger trigger)    {        if (_stateTransitions.TryGetValue((CurrentState, trigger), out OrderState newState))        {            Console.WriteLine($\"Moving from {CurrentState} to {newState} due to {trigger}\");            CurrentState = newState;        }        else        {            Console.WriteLine($\"Invalid transition: {CurrentState} cannot handle {trigger}\");        }    }}  Client :class Program{    static void Main()    {        var orderStateMachine = new OrderStateMachine();        Console.WriteLine($\"Initial state: {orderStateMachine.CurrentState}\");        // Simulating order processing        orderStateMachine.ProcessTransition(OrderStateMachine.OrderTrigger.Pay);        orderStateMachine.ProcessTransition(OrderStateMachine.OrderTrigger.Ship);        orderStateMachine.ProcessTransition(OrderStateMachine.OrderTrigger.Deliver);    }}How It Works      The OrderStateMachine class encapsulates state logic, making the main program cleaner.        The CurrentState property tracks the current order state.        The _stateTransitions dictionary holds valid state transitions.        The ProcessTransition() method checks for valid transitions and updates the state.        The Main method initializes the state machine and processes transitions.  ConclusionState machines are an excellent way to manage complex workflows in a clean, predictable manner. Using a simple dictionary in C#, we can build a flexible and maintainable system to handle order states. By encapsulating state logic in a class, we make our code cleaner, more modular, and easier to maintain. Whether you’re working on UI workflows, business processes, or game logic, state machines provide a structured approach to managing state transitions effectively."
    },
  
    {
      "title": "Design Patterns: Prototype",
      "url": "/design-patterns-prototype",
      "date": "2025-04-14",
      "tags": "cleancode, csharp, designpatterns, prototype",
      "content": "In software development, there are scenarios where creating multiple objects with similar attributes and configurations is necessary. Instead of constructing each object from scratch, a more efficient approach is to duplicate an existing instance. This is precisely what the Prototype Design Pattern facilitates.What is the Prototype Pattern?The Prototype pattern is a creational design pattern that focuses on cloning objects. Rather than instantiating new objects directly, this pattern allows for the creation of copies of existing instances. This can be particularly beneficial when object creation is expensive or complex.Benefits of Using the Prototype Pattern      Improved Performance – If object creation involves expensive operations such as database queries or intensive computations, cloning can optimize performance.        Simplified Object Initialization – When an object requires extensive setup, cloning eliminates redundant initialization steps.        Dynamic Object Modifications – Prototypes can be modified at runtime, enabling flexible object creation.  Implementing the Prototype Pattern in C#General ApproachA common way to implement the Prototype pattern is by defining a prototype interface that declares a cloning method. This ensures that all implementing classes provide their own cloning logic, allowing for consistent object duplication.public interface IPrototype&lt;T&gt;{    T Clone();}Using a generic interface allows different types to define their own cloning mechanisms while ensuring type safety. In C#, there is already provided ICloneable interface which has the same intention.Step 1: Implement a Concrete ClassConsider a Car class that implements ICloneable:public class Car : ICloneable{    public string Model { get; set; }    public string Color { get; set; }        public Car(string model, string color)    {        Model = model;        Color = color;    }        public object Clone()    {        return new Car(this.Model, this.Color);    }}  Step 2: Clone ObjectsNow, we can create and modify cloned objects efficiently:Car car1 = new Car(\"Tesla Model S\", \"Red\");Car car2 = (Car)car1.Clone();car2.Color = \"Blue\";Console.WriteLine($\"Car1: {car1.Model}, {car1.Color}\"); // Output: Car1: Tesla Model S, RedConsole.WriteLine($\"Car2: {car2.Model}, {car2.Color}\"); // Output: Car2: Tesla Model S, Blue  The car2 instance is cloned from car1, and its color is modified independently.When to Use the Prototype PatternThis pattern is particularly useful when:  Object creation is resource-intensive, and cloning provides a more efficient alternative.  There is a need to generate multiple similar objects dynamically.  Avoiding complex initialization logic enhances maintainability.When Not to Use the Prototype Pattern  If object creation is straightforward, cloning may introduce unnecessary complexity.  If an object depends on external resources that should not be duplicated, such as database connections.ConclusionThe Prototype Design Pattern is a practical solution for optimizing object creation in C#. By leveraging the ICloneable interface, we can efficiently create and modify objects while maintaining code simplicity and efficiency."
    },
  
    {
      "title": "Code Review Best Practices",
      "url": "/code-review-best-practices",
      "date": "2025-04-07",
      "tags": "cleancode, codereview, coding, developer",
      "content": "Code reviews are a crucial part of writing great software. They help maintain code quality, catch bugs early, and improve collaboration. But if done poorly, they can be frustrating, time-consuming, and even demotivating. So, how do you make your code reviews effective and useful?What to Do?1. Prioritize Code Quality and Maintainability      Make sure the code follows best practices and style guidelines.        Check for ways to improve performance and efficiency.        Ensure the code is easy to read and well-structured.  2. Give Constructive, Respectful Feedback      Focus on helping, not just pointing out mistakes.        Offer suggestions rather than just criticism.        Highlight things that were done well, not just areas that need improvement.  3. Ensure the Code is Properly Tested      Look for unit tests and integration tests where needed.        Check for edge cases and possible failure points.        Make sure tests actually pass before approving the PR.  4. Look Out for Security and Performance Issues      Watch for common security risks like SQL injection, XSS, and hardcoded secrets.        Keep an eye on database queries and API calls for efficiency.        Avoid unnecessary complexity that could slow things down.  5. Make Sure the Code Solves the Right Problem      Confirm that the implementation matches the requirements.        If there are UI changes, make sure they align with design specs.        Double-check that the solution is practical and efficient.  6. Encourage Small, Manageable PRs      Reviewing smaller pull requests is faster and more effective.        Give feedback promptly so you don’t block progress.        Encourage breaking big changes into smaller, focused updates.  7. Use Automation to Catch Basic Issues      Rely on linters and static analysis tools for style enforcement.        Let CI/CD pipelines handle basic testing and code coverage checks.        Automate formatting so you don’t have to waste time on minor faults.  What Not to Do?1. Don’t Make It Personal      Critique the code, not the developer.        Use respectful, inclusive language.        Remember that everyone, no matter how experienced, makes mistakes.  2. Don’t Rush Through The Review      Take the time to understand the code before commenting.        Avoid approvals without actually checking the details.        Make sure your feedback is clear and actionable.  3. Don’t Hold Up Reviews For Too Long      Give feedback as soon as possible to keep things moving.        If you’re busy, let the team know so they can adjust expectations.  4. Don’t Expect Perfection Right Away      It’s okay if the first draft isn’t perfect—focus on incremental improvements.        Balance high standards with realistic expectations.  5. Don’t Overcomplicate Things      Keep suggestions practical and easy to follow.        Avoid unnecessary refactoring unless it truly improves the code.  Final ThoughtsCode reviews should be a positive, collaborative process. They’re not just about finding mistakes—they’re about making the code better and helping each other grow as developers. Keep feedback constructive, focus on maintainability, and use automation where you can to make the process smoother. Most importantly, remember that you are all on the same team, and that you are improving your product together.Happy coding and happy reviewing!"
    },
  
    {
      "title": "TDD and Mocking",
      "url": "/tdd-and-mocking",
      "date": "2025-04-01",
      "tags": "cleancode, csharp, tdd, unittesting, dependencyinjection, moq",
      "content": "In the last post we have discussed core principles of unit testing and TDD. In this post, we’ll walk through a simple example of how to use Moq  as mocking framework and Dependency Injection with NUnit in the context of Test-Driven Development (TDD) in C#. This combination allows for clean, maintainable tests by mocking dependencies and focusing on the behavior of the system under test.Imagine we have an application where we process payments through a PaymentService. This service depends on an external IPaymentGateway interface to make the actual payment.Let’s break this down step by step.Step 1: Write the Test First (Before Code)We want to test the PaymentService, which depends on the IPaymentGateway. Our first test will focus on making sure the PaymentService behaves correctly when making a valid payment.Here’s the test code:using Moq;using NUnit.Framework;[TestFixture]public class PaymentServiceTests{    private Mock&lt;IPaymentGateway&gt; _mockPaymentGateway;    private PaymentService _paymentService;    [SetUp]    public void Setup()    {        // Create the mock object        _mockPaymentGateway = new Mock&lt;IPaymentGateway&gt;();        // Inject the mock into the PaymentService        _paymentService = new PaymentService(_mockPaymentGateway.Object);    }    [Test]    public void MakePayment_WhenAmountIsValid_ShouldReturnTrue()    {        // Arrange        var amount = 100m; // Valid amount        _mockPaymentGateway.Setup(gateway =&gt; gateway.ProcessPayment(amount)).Returns(true);        // Act        var result = _paymentService.MakePayment(amount);        // Assert        Assert.IsTrue(result);    }}Step 2: Run the Test (It Will Fail)Since we haven’t implemented the PaymentService or the IPaymentGateway yet, running the test will result in a failure. The error message would indicate that the PaymentService and IPaymentGateway don’t exist yet.Now we need to implement the minimal code to make this test pass.Step 3: Write the Code to Pass the TestWe need to create the PaymentService and IPaymentGateway interface so that the test can run successfully.Here’s the implementation of the IPaymentGateway interface and the PaymentService class:public interface IPaymentGateway{    bool ProcessPayment(decimal amount);}public class PaymentService{    private readonly IPaymentGateway _paymentGateway;    public PaymentService(IPaymentGateway paymentGateway)    {        _paymentGateway = paymentGateway;    }    public bool MakePayment(decimal amount)    {        // Business logic for validating amount (e.g., check if it's positive)        if (amount &lt;= 0)        {            return false;        }        // Process the payment through the gateway        return _paymentGateway.ProcessPayment(amount);    }}Step 4: Run the Test Again (It Should Pass)Now that we’ve implemented the PaymentService and IPaymentGateway, we can run the test again.If everything is set up correctly, this time the test should pass. The output should indicate that the MakePayment method of the PaymentService is functioning as expected, returning true when a valid amount is passed and the gateway returns true.Step 5: Write Another Test (The Test-Grow Approach)The next step in TDD is to write another test for a different scenario. In this case, we will test when an invalid payment amount is passed (e.g., a negative or zero amount). Let’s write this test.Here’s the next test:[Test]public void MakePayment_WhenAmountIsInvalid_ShouldReturnFalse(){    // Arrange    var amount = -50m; // Invalid amount    _mockPaymentGateway.Setup(gateway =&gt; gateway.ProcessPayment(It.IsAny&lt;decimal&gt;())).Returns(false);    // Act    var result = _paymentService.MakePayment(amount);    // Assert    Assert.IsFalse(result);}Step 6: Refactor the Code if NeededNow, we have a test for the invalid case, and we should implement any additional logic if necessary to make this test pass. In our current code, the logic already returns false if the amount is less than or equal to 0. This means the code is already correct, and we don’t need to change anything.ConclusionThis example demonstrates how to apply Test-Driven Development in C# with NUnit, Moq, and Dependency Injection. By mocking dependencies, you can easily test the behavior of your services without relying on the real implementations, making your tests faster and more reliable. Dependency injection ensures that dependencies are easily replaceable, promoting clean, maintainable code."
    },
  
    {
      "title": "Unit Testing and Test-Driven Development (TDD) in C#",
      "url": "/unit-testing-and-test-driven-development-tdd-in-csharp",
      "date": "2025-03-24",
      "tags": "cleancode, csharp, tdd, unittesting",
      "content": "Writing code without unit tests can be risky—you might not realize issues until it’s too late. Unit testing helps make sure your code actually does what it’s supposed to. In this post, we’ll break down unit testing in C# using NUnit and explore how Test-Driven Development (TDD) can make your life easier.What’s Unit Testing Anyway?Unit testing is all about testing small, isolated chunks of your code to make sure they work correctly. Instead of waiting until the whole application is built and then scrambling to fix bugs, unit tests let you catch issues early. In C#, we typically use frameworks like NUnit , xUnit , or MSTest to write and run these tests.Why Should You Care About Unit Testing?      Find Bugs Early: Fixing issues sooner rather than later saves time (and headaches).        Make Your Code More Maintainable: Well-tested code is easier to update and improve.        Write Better Code: Writing testable code forces you to structure it well.        Acts as Documentation: Your tests describe what your code is supposed to do.  What is Test-Driven Development (TDD)?TDD is a mindset shift where you write your tests before you write the actual implementation. It follows a simple cycle:  Write a test that fails (because the feature doesn’t exist yet).  Write just enough code to make the test pass.  Refactor and clean up the code while keeping the test green.Why Bother with TDD?      Guarantees better test coverage.        Helps you write only the code you actually need.        Saves you time debugging later.        Makes your code modular and easy to change.        Every test case serves as a description of a use case, making tests a form of living documentation for your code.        Encourages better code structure by promoting loose coupling, dependency injection, and composition-based design patterns.  Step-by-Step Guide: TDD with NUnit in C#Step 1: Setting Up NUnit in Your ProjectGetting started is easy:  Create a new NUnit Test Project in Visual Studio.  Install NUnit and NUnit3TestAdapter via NuGet.  Add a reference to the project containing the code you want to test.Step 2: Write a Failing TestLet’s use TDD to build a Calculator class with an Add method. First, create a test class CalculatorTests.cs and add this test:using NUnit.Framework;[TestFixture]public class CalculatorTests{    [Test]    public void Add_TwoNumbers_ReturnsSum()    {        var calculator = new Calculator();        int result = calculator.Add(2, 3);        Assert.AreEqual(5, result); // This test will fail since the method doesn’t exist yet    }}Step 3: Write Just Enough Code to Pass the TestSince our Calculator class and Add method don’t exist yet, let’s create them:public class Calculator{    public int Add(int a, int b) =&gt; a + b;}Run the test—it should now pass!Step 4: Add More Tests and Implement SubtractionNext, let’s implement a Subtract method using the same TDD approach.  Write a test first:[Test]public void Subtract_TwoNumbers_ReturnsDifference(){    var calculator = new Calculator();    int result = calculator.Subtract(5, 3);    Assert.AreEqual(2, result); // This test will fail initially}  Write just enough code to pass the test:public int Subtract(int a, int b) =&gt; a - b;  Refactor if needed to keep your code clean and efficient.Step 5: Run and Verify Your TestsUse Visual Studio’s Test Explorer to run all your tests. If they pass, congrats! You’ve successfully followed the TDD cycle.How TDD Improves Code StructureIf TDD is applied properly, the following structural benefits emerge:      Loose Coupling: Since tests require isolating components, TDD encourages designing classes that don’t depend too much on each other.        Dependency Injection: Writing testable code often means injecting dependencies instead of hardcoding them, leading to better modularity.        Composition Over Inheritance: Rather than relying too much on inheritance, TDD pushes towards a composition-based approach, making code more flexible.        Separation of Concerns: Following the TDD cycle helps ensure each class has a single responsibility, making it easier to maintain and extend.        Improved Testability: The necessity to test first forces developers to create well-structured, reusable components that are easier to test in isolation.  Pro Tips for Writing Good Unit Tests      Stick to the AAA (Arrange-Act-Assert) pattern to keep tests clean and readable.        Make tests independent—don’t let them rely on external data or states.        Use mocking frameworks like Moq to isolate dependencies.        Keep tests fast and focused—each test should check just one thing.        Avoid over-testing trivial methods like simple property getters.  Wrapping UpUnit testing (especially with TDD) makes your code more reliable, easier to maintain, and less prone to bugs. Since each test case describes a specific use case, they double as a form of documentation for how your code is expected to behave. Additionally, applying TDD properly leads to better code structure through dependency injection, loose coupling, and composition-based patterns.In the next post, we’ll dive deeper into mocking —an essential technique for isolating dependencies and making unit tests more effective. Stay tuned!"
    },
  
    {
      "title": "Dependency Injection In .NET Core With Strategy Pattern",
      "url": "/dependency-injection-in-net-core-with-strategy-pattern",
      "date": "2025-03-24",
      "tags": "csharp, dependencyinjection, netcore, strategy",
      "content": "In the previous post, we gave an introduction and explained the basic concept of the Strategy Pattern. Now, we want to go a bit further and demonstrate how it works in practice alongside a dependency injection in .NET Core. Instead of manually instantiating strategies, we let the ASP.NET Core DI container inject the correct implementation at runtime.ExampleFor the showing purposes, let us asume that we are implementing some payment service, and we want to use one service at the time, depending on user input.For our strategy pattern, we would need following components:Interfacepublic interface IPaymentStrategy{    void Pay(decimal amount);}Concrete Strategiespublic class CreditCardPayment : IPaymentStrategy{    public void Pay(decimal amount)    {        Console.WriteLine($\"Paid ${amount} using Credit Card.\");    }}public class PayPalPayment : IPaymentStrategy{    public void Pay(decimal amount)    {        Console.WriteLine($\"Paid ${amount} using PayPal.\");    }}public class BitcoinPayment : IPaymentStrategy{    public void Pay(decimal amount)    {        Console.WriteLine($\"Paid ${amount} using Bitcoin.\");    }}Contextpublic interface IPaymentContext{    void ExecutePayment(string paymentMethod, decimal amount);}public class PaymentContext : IPaymentContext{    private readonly IServiceProvider _serviceProvider;    public PaymentContext(IServiceProvider serviceProvider)    {        _serviceProvider = serviceProvider;    }    public void ExecutePayment(string paymentMethod, decimal amount)    {        IPaymentStrategy strategy = paymentMethod switch        {            \"creditcard\" =&gt; _serviceProvider.GetService&lt;CreditCardPayment&gt;(),            \"paypal\" =&gt; _serviceProvider.GetService&lt;PayPalPayment&gt;(),            \"bitcoin\" =&gt; _serviceProvider.GetService&lt;BitcoinPayment&gt;(),            _ =&gt; throw new ArgumentException(\"Invalid payment method\")        };        strategy.Pay(amount);    }}Next, we are implementing our controller:using Microsoft.AspNetCore.Mvc;[Route(\"api/[controller]\")][ApiController]public class PaymentController : ControllerBase{    private readonly IPaymentContext _paymentContext;    public PaymentController(IPaymentContext paymentContext)    {        _paymentContext = paymentContext;    }    [HttpPost(\"{paymentMethod}\")]    public IActionResult ProcessPayment(string paymentMethod, [FromBody] decimal amount)    {        _paymentContext.ExecutePayment(paymentMethod.ToLower(), amount);        return Ok($\"Payment of ${amount} processed using {paymentMethod}.\");    }}And, we register each payment strategy in Program.cs.using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.DependencyInjection;using Microsoft.Extensions.Hosting;var builder = WebApplication.CreateBuilder(args);// Register concrete strategiesbuilder.Services.AddTransient&lt;CreditCardPayment&gt;();builder.Services.AddTransient&lt;PayPalPayment&gt;();builder.Services.AddTransient&lt;BitcoinPayment&gt;();builder.Services.AddTransient&lt;IPaymentContext, PaymentContext&gt;();// Register controllersbuilder.Services.AddControllers();var app = builder.Build();app.UseHttpsRedirection();app.UseAuthorization();app.MapControllers();app.Run();How It Works  The DI container registers each strategy (CreditCardPayment, PayPalPayment, BitcoinPayment).  The controller receives an IPaymentContext, which allows it to dynamically resolve the appropriate payment strategy.  When a user makes a payment request, the context dynamically selects the strategy based on the URL parameter (creditcard, paypal, bitcoin).  The selected strategy is injected into the PaymentContext and executed.ConclusionFinally, we can highlight some key points on why this approach offers significant benefits to the code structure.  Loose Coupling – The controller does not depend on concrete implementations, making the code more flexible.  Easy Maintenance – New payment methods can be added without modifying existing code.  Testability – The strategies can be mocked and tested independently.  Runtime Flexibility – The payment method can be selected dynamically at runtime."
    },
  
    {
      "title": "How To Pay Programmers Less",
      "url": "/how-to-pay-programmers-less",
      "date": "2025-03-17",
      "tags": "developer, job",
      "content": "Before we kick off, just a quick mention that the intention of this post is pure fun, so please don’t take it too seriously! :) ….Hiring and retaining top programming talent is expensive, but reducing costs doesn’t have to mean cutting corners. Instead of simply lowering salaries, businesses can use smart (and slightly sneaky) strategies to optimize their workforce, keep developers motivated, and ensure productivity remains high while keeping costs manageable.Create a Family Like EnvironmentBecause nothing says “family” like a workplace where you’re expected to answer emails at midnight! But seriously, a strong company culture can make employees feel valued and connected, reducing turnover and salary demands. Foster a workplace that emphasizes:      Open communication : Encourage feedback and transparency to build trust. Just be sure to ignore any feedback that involves “higher salaries.”        Team bonding activities : Regular pizza parties, yearly company events, and casual outings help employees feel part of a supportive family (one that conveniently pays them less).        Mentorship programs : Pairing junior developers with experienced mentors strengthens team cohesion and conveniently reduces the need for expensive senior hires.        Recognition and appreciation : Celebrate achievements with shoutouts, small rewards, or—if you’re feeling generous—an extra slice of pizza at the next party.  Offer Non-Moneraty PerksCompetitive salaries attract programmers, but additional perks can reduce the pressure on salary increases. Consider offering:      Remote work opportunities (so they can code in pajamas, which is priceless).        Flexible schedules to improve job satisfaction (and also make it easier for them to work late without realizing it).        Equity or profit-sharing to align developer interests with company success (which may or may not ever be worth anything).        Pizza parties and yearly company events to keep morale high while pay stays low.  Hire Junior Developers and Train ThemSenior developers demand higher salaries, and who needs that? Hire promising junior developers and upskill them instead! Bonus: Juniors are too fresh to realize how underpaid they are.Optimize Team SizeBigger teams don’t always mean better results. A smaller, highly skilled team can often outperform a larger, less experienced one. The trick? Just never tell your existing team that you won’t be replacing the three developers who just quit.Use Performance-Based CompensationInstead of high base salaries, offer performance-based incentives. Bonuses tied to project completion, efficiency, or quality metrics can help reduce fixed costs while keeping programmers motivated. A modest 3% yearly raise can be positioned as a “reward”—even though it barely covers inflation.ConclusionLowering programmer costs doesn’t have to mean paying unfair wages or sacrificing quality. By optimizing processes, leveraging automation, using alternative hiring strategies, and fostering a family-like work environment (minus the inheritance), companies can maintain a strong development team while managing expenses wisely.By applying these strategies, businesses can ensure they are paying only what is necessary while still attracting and retaining top talent—because where else are they going to go, right?"
    },
  
    {
      "title": "Design Patterns: Decorator",
      "url": "/design-patterns-decorator",
      "date": "2025-03-10",
      "tags": "csharp, decorator, designpatterns, softwarearhitecture",
      "content": "The Decorator Pattern is a structural design pattern that allows behavior to be dynamically added to individual objects, without modifying their code. It is often used to extend the functionalities of classes in a flexible and reusable way.When To Use It?  You Need to Add Behavior Dynamically at Runtime. Example: A coffee shop app where users can customize their drinks with add-ons like Milk, Sugar, Whipped Cream, etc.  You Want to Avoid a Large Inheritance Tree.  If you use inheritance, each combination of behaviors would require a new subclass (e.g., CoffeeWithMilk, CoffeeWithSugar, CoffeeWithMilkAndSugar, etc.).  You Want More Flexible and Reusable Code. Different decorators can be reused independently. Example: A LoggingDecorator, CompressionDecorator, and EncryptionDecorator can be used separately or in different orders.  You Follow the Open-Closed Principle. Instead of modifying an existing class, you can extend behavior using decorators. This makes your code more maintainable.  You Need to Combine Multiple Independent Behaviors. Example: A text editor where you can apply bold, italics, and underline without modifying the base class.When Not To Use It?  The Object’s Behavior Doesn’t Change at Runtime. If an object’s behavior is fixed and won’t need modifications dynamically.  The Number of Possible Combinations is Small  Alternative Patterns Are Simpler. If you need different behaviors but don’t need stacking, the strategy pattern may be a better choice. If you have a few known configurations, a factory might be more maintainable.Example in C#Interfacepublic interface ICoffee{    string GetDescription();    double GetCost();}  Concrete Component Implementationpublic class SimpleCoffee : ICoffee{    public string GetDescription()    {        return \"Simple Coffee\";    }    public double GetCost()    {        return 5.0; // Base price of coffee    }}Abstract Decoratorpublic abstract class CoffeeDecorator : ICoffee{    protected ICoffee _coffee;    public CoffeeDecorator(ICoffee coffee)    {        _coffee = coffee;    }    public virtual string GetDescription()    {        return _coffee.GetDescription();    }    public virtual double GetCost()    {        return _coffee.GetCost();    }}Concrete Decoratorspublic class MilkDecorator : CoffeeDecorator{    public MilkDecorator(ICoffee coffee) : base(coffee) { }    public override string GetDescription()    {        return _coffee.GetDescription() + \", Milk\";    }    public override double GetCost()    {        return _coffee.GetCost() + 1.5; // Extra cost for milk    }}public class SugarDecorator : CoffeeDecorator{    public SugarDecorator(ICoffee coffee) : base(coffee) { }    public override string GetDescription()    {        return _coffee.GetDescription() + \", Sugar\";    }    public override double GetCost()    {        return _coffee.GetCost() + 0.5; // Extra cost for sugar    }}Clientclass Program{    static void Main()    {        // Create a simple coffee        ICoffee coffee = new SimpleCoffee();        Console.WriteLine($\"{coffee.GetDescription()} - ${coffee.GetCost()}\");        // Add milk to the coffee        coffee = new MilkDecorator(coffee);        Console.WriteLine($\"{coffee.GetDescription()} - ${coffee.GetCost()}\");        // Add sugar to the coffee        coffee = new SugarDecorator(coffee);        Console.WriteLine($\"{coffee.GetDescription()} - ${coffee.GetCost()}\");    }}ConclusionThe Decorator Pattern is a great tool for extending functionality dynamically while keeping the base code clean and modular. It is widely used in the .NET Core framework and its libraries to provide flexible and extendable functionality. Some of the usages are:  Middleware Pipeline ,  app.UseMiddleware()  Logging, ILogger with multiple providers (Console, Debug, etc.)  Caching, IMemoryCache, IDistributedCache"
    },
  
    {
      "title": "Testable WinForms Applications (MVP pattern)",
      "url": "/testable-winforms-applications-mvp-pattern",
      "date": "2025-03-03",
      "tags": "csharp, designpatterns, mvp, winforms",
      "content": "Today, WinForms apps mainly belong to legacy code because of increasing popularity of WPF. And when one team decides about the development stack for the brand new desktop application, they mainly vote for WPF. On the other hand, there are demands for WinForms applications when it is needed to upgrade existing software which is tightly coupled with WinForms, demands for higher performance, etc.Different ApproachesThere are many opinions on the subject about testable WinForms apps. Some claim that it’s not possible to test WinForms apps because there is a lot of dependency between user events and business logic.Standard Windows Form contains Designer.cs partial class and a partial class which contains event handlers for user actions. So, if we follow this same principle and try to implement app logic in event handlers, we can conclude that it would be very hard to write tests for this kind of application. But, if we look at this problem from some distance, we can conclude that every application with user interface could be represented as an interaction between three main components: Data, User Interface and Business Logic.This is the basic idea of MV* patterns. If we succeed to segregate these three components, then our application is on a good way to be testable. I made a simple WinForms app using MVP pattern. The entire project could be fetched from github.In this post, I would just use code snippets to give a general idea of how the code looks like.But First, Few Words About MVP PatternMVP stands for Model-View-Presenter. Model is a component that contains data. It is just a data holder for our forms. View represents the User Interface. It contains design description of our form. Presenter is a component that does most of the job in our WinForms app. It is subscribed to view events and those events are results of user interaction with our form (clicks on buttons, text change, selection change, etc.) and OS interaction with our form (load, show, paint, etc.). Presenter needs to handle all these events and, after their processing, make appropriate action on the view.Code StructureLet’s start with our view component.public interface IProductView{     event EventHandler ViewLoad;     event EventHandler&lt;ProductViewModel&gt; AddNewProduct;     event EventHandler&lt;ProductViewModel&gt; ModifyProduct;     event EventHandler&lt;int&gt; DeleteProduct;     event EventHandler&lt;int&gt; ProductSelected;     void PopulateDataGridView(IList&lt;Product&gt; products);     void ClearInputControls();     void ShowMessage(string message);}public partial class Products : Form, IProductView{    ...}We created an interface IProductView that defines rules how Presenter and User Interface component will interact. Now, let’s take a look at our presenter component.public class ProductPresenter{    private IProductView view;    private IProductDataAccess dataAccesService;        public ProductPresenter(IProductView view, IProductDataAccess dataAccesService)    {        this.view = view;        this.dataAccesService = dataAccesService;        SubsribeToViewEvents();    }    private void SubsribeToViewEvents()    {        view.ViewLoad += View_Load;        view.AddNewProduct += View_AddNewProduct;        view.ProductSelected += View_ProductSelected;        view.ModifyProduct += View_ModifyProduct;        view.DeleteProduct += View_DeleteProduct;    }    ...}Our presenter takes IProductView interface in its constructor. By this way, our view (form) can easily be replaced with another view which implements the same interface. Also, when it comes to mocking, we can easily inject this dependency through constructor. Another component is IProductDataAccess which represents database interface.public interface IProductDataAccess{    IList&lt;Product&gt; GetAllProducts();    Product GetProduct(int id);    bool AddProduct(Product product);    bool DeleteProduct(int productId);    bool EditProduct(int productId, Product product);    string ErrorMessage { get; }}  One Test Case ExampleThis test case shows how we can easily mock external dependencies in Presenter component. [Test] public void ExpectToCallAddProductOnAppropriateEventReceived() {     IProductView view = Substitute.For&lt;IProductView&gt;();     IProductDataAccess dataAccess = Substitute.For&lt;IProductDataAccess&gt;();     ProductPresenter presenter = new ProductPresenter(view, dataAccess);                ProductViewModel viewModel = new ProductViewModel()     {         NameText = \"Test\",         PriceText = \"2\"     };                view.AddNewProduct +=           Raise.Event&lt;EventHandler&lt;ProductViewModel&gt;&gt;(view, viewModel);     dataAccess.Received().AddProduct(Arg.Is&lt;Product&gt;                           (x=&gt;x.Price == 2 &amp;&amp; x.Name == \"Test\")); }  ConclusionThis is just a simple example of how powerful an architecture that starts with an abstraction can be. It is always better to start with some components on the higher level and then, defining the interfaces, you define rules how those components will interact with each other."
    },
  
    {
      "title": "Design Patterns: Strategy",
      "url": "/design-patterns-strategy",
      "date": "2025-02-17",
      "tags": "cleancode, csharp, designpatterns, strategy",
      "content": "The Strategy Pattern is a behavioral design pattern that defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern allows the algorithm to be selected at runtime, providing flexibility in designing software. It’s particularly useful when you have multiple ways of performing a task, and you want to choose the implementation dynamically without altering the client code.When To Use It?  You Have Multiple Algorithms or Behaviors. Use it when you have a need for muplitple ways of performing a task, and you want to make these implementations interchangeable. Examples: Different sorting algorithms, payment methods, discount calculations…  You Want to Eliminate Conditional Logic. If you find yourself writing large if-else or switch statements to decide which algorithm to use, this pattern can simplify and clean up your code. Examples: A game character with different attack styles  You Need Runtime Flexibility. Use this pattern if the choice of algorithm or behavior needs to be decided dynamically at runtime rather than compile-time. Example: A game character that changes its movement strategy based on terrain type.When Not To Use It?  The Behavior is Unlikely to Change. If the behavior or algorithm is stable and unlikely to require changes, introducing the this pattern may add unnecessary complexity. Example: A basic calculator where operations (add, subtract) are fixed.  You Don’t Need Runtime Flexibility. If the algorithm is chosen at compile-time or hardcoded, the strategy pattern is overkill.  Strategies Require Too Much Shared State. If the strategies rely heavily on the internal state of the context class, they can become tightly coupled, defeating the purpose of the pattern.Key Components  Strategy Interface: Defines a common interface for all the algorithms (strategies).  Concrete Strategies: Implement different versions of the algorithm defined in the strategy interface.  Context: Maintains a reference to a Strategy object and delegates the work to the strategy.Example in C#Interfacepublic interface IMoveStrategy{    void Move();}Concrete Strategiespublic class Crouch : IMoveStrategy{    public void Move()    {        Console.WriteLine(\"Character is crouching slowly...\");    }}public class Walk : IMoveStrategy{    public void Move()    {        Console.WriteLine(\"Character is walking at a normal pace...\");    }}public class Run : IMoveStrategy{    public void Move()    {        Console.WriteLine(\"Character is running fast...\");    }}Contextpublic class CharacterContext{    private IMoveStrategy _moveStrategy;    public CharacterContext(IMoveStrategy moveStrategy)    {        _moveStrategy = moveStrategy;    }    public void SetMovementStrategy(IMoveStrategy moveStrategy)    {        _moveStrategy = moveStrategy;    }    public void ExecuteMove()    {        _moveStrategy.Move();    }}Clientusing System;class Program{    static void Main(string[] args)    {        // Create a character with an initial movement strategy (Walk)        CharacterContext character = new CharacterContext(new Walk());        while (true)        {            Console.WriteLine(\"\\nChoose movement: crouch, walk, run, or exit.\");            string input = Console.ReadLine()?.ToLower();            if (input == \"exit\")                break;            // Manually select the strategy based on user input            IMoveStrategy selectedStrategy = input switch            {                \"crouch\" =&gt; new Crouch(),                \"walk\" =&gt; new Walk(),                \"run\" =&gt; new Run(),                _ =&gt; null            };            if (selectedStrategy != null)            {                character.SetMovementStrategy(selectedStrategy);                character.ExecuteMove();            }            else            {                Console.WriteLine(\"Invalid input! Please enter crouch, walk, or run.\");            }        }    }}ConclusionThe Strategy Pattern provides flexibility, scalability, and cleaner code, making it a great choice for scenarios like game character movement, AI behavior, and dynamic algorithm selection."
    },
  
    {
      "title": "Composition Over Inheritence",
      "url": "/composition-over-inheritence",
      "date": "2025-02-10",
      "tags": "composition, csharp, designpatterns, inheritence",
      "content": "Inheritence is often misused or overused or even forced for several reasons, and they are mostly due to education, misunderstanding or habit. Many developers who studied OOP are introduced with inheritence in early stage and then it stays with them as a default way how to build relationships between objects. Escaping this matrix can be quite challenging, as lacking alternative perspectives often leads to the trap of believing that inheritance is the solution to everything. Here, we will try to find the reasoning behind this way of thinking.Historical InfluenceEarly OOP examples often revolved around “is-a” relationships like Car -&gt; Vehicle, Dog -&gt; Animal, reinforcing inheritance as the primary method of code reuse. We can see this in early OOP literature, such as the influential “Gang of Four Design Patterns”,  where inheritance is prominently discussed. And then, as a result, developers internalized it as the default design approach.Inheritance = Code Reuse (Misconception)Many developers learn that inheritance is the primary way to reuse code. They might think: “If I need to reuse functionality, I must derive from a base class.” This mindset leads to deep hierarchies, tight coupling, even when simpler or more modular solutions (like composition) would work better.Simplicity of ImplementationInheritance is Easy to Implement - defining a base class and extending it is straightforward, both conceptually and in terms of syntax. Composition requires more design work, such as defining interfaces or injecting dependencies. Let’s show the difference in one simple example:Inheritencepublic class Vehicle { \tpublic void Move() \t{ \t\tConsole.WriteLine(\"Moving\"); \t} }public class Car : Vehicle { }Compositionpublic interface IMovable { \tvoid Move(); }public class Car { \tprivate readonly IMovable _movable; \tpublic Car(IMovable movable) \t{ \t\t_movable = movable; \t} }Legacy codeOlder systems were built using inheritance-heavy designs, and developers working on these systems are forced to maintain and extend these hierarchies.Frameworks that Encourage InheritanceMany frameworks historically relied on inheritance (e.g., GUI frameworks like Swing or .NET’s WinForms) where developers extended base classes to customize behavior.Developers often mimic these patterns without questioning if they’re the best solution.How to Shift Away from Overusing InheritanceEducate About Composition:Teach patterns like Strategy, Decorator, and Dependency Injection as alternatives to deep hierarchies. Example: Instead of a Car base class, use a IMovable, IEngine interface and inject behavior dynamically.Promote Design Principles:Follow SOLID principles, especially:  Single Responsibility: Avoid bloated base classes.  Dependency Inversion: Prefer abstractions over specific implementations.Use Interfaces and Delegation:Example: Instead of class Car : Vehicle, use Car with a composable IEngine or IMovable.Emphasize Refactoring:Refactor overly complex hierarchies into flatter, modular designs using composition.ConclusionInheritance is often “forced” because it’s historically emphasized, easy to use, and aligns with developers’ early understanding of OOP. However, it has significant limitations that make composition a more flexible, scalable, and maintainable choice in many scenarios. By learning and applying composition patterns, developers can avoid rigid hierarchies and design systems that are more robust and adaptable."
    },
  
    {
      "title": "Unreasonable Deadlines",
      "url": "/unreasonable-deadlines",
      "date": "2025-02-04",
      "tags": "agile, deadlines, developer, engineering",
      "content": "“This is the last time I am doing overtime hours. It won’t happen again for sure.” You are thinking about this and in the meantime your team lead comes into the office and interrupts your thoughts with the similar story: ”Hey guys, only this time we need to do extra effort and after that we will be more concerned about deadlines.” Few months later, a new project and the same story. Sounds familiar?ReasonsThis can be due to vary of reasons. Some of them could be:  Poor planning is reflected by inadequate scoping and requirements. Without a clear understanding what needs to be done, it’s impossible to give a good estimate.  False optimism by decision makers. Tendency to not think about the details, thinking everything would go smoothly. But if something could go wrong, it will (always) ☺  Pressure from clients who are pushing for fast results to meet market demands.  Underestimating external dependencies. Not giving enough attention to the third party interface integration.  Hero Culture. Teams may embrace a toxic “work harder, not smarter” mentality, leading to overpromising and underdelivering.What to do in order to fix it?Allthough there is no silver bullet that can fix everything at once, some of the approaches that could help are:  Make communication more transparent. Encourage open discussions and stick to realistic goals.  Automate repetitive tasks. Automate testing and CI/CD pipelines.  Adopt agile practices. Divide scope, try to give realistic estimates on smaller pieces. Make use of retrospectives and reviews of previous projects.  Divide project to more deliverable portions. Clients would be happy to see that something is happening, and also would be able to give some initial feedback. On the other side, you will have clearer picture on what needs to be done and how fast it can be delivered.  Hold leaders accountable. Good leaders push back against unreasonable deadlines, first to maintain good team morale, and second to build trustworthiness with clients.ConclusionUnreasonable deadlines might seem unavoidable, but their long-term costs outweigh short-term gains. Foster realistic expectations, plan effectively, and communicate openly to build a sustainable, productive engineering culture."
    },
  
    {
      "title": "Why Do Employers Lie In Interviews?",
      "url": "/why-do-employers-lie-in-interviews",
      "date": "2025-02-03",
      "tags": "developer, hiring, hr, interview",
      "content": "This is a very common subject that many of us have already experienced. But when you realize that half of what has been said at interviews is actually a lie, you are already at least six months in the company, you have already started some project and it wouldn’t be appropriate to leave the company at that moment.Why is this happening?First of all, let us see how the usual interview process looks like in software development companies.First round interview in most of these companies is an interview with HR. This is the first insight about the company. A person who works in HR is usually someone who, in most cases, doesn’t understand what the software is and how the software development process goes. Big respect to those companies where HR knows these things. This phase usually contains some standard questions about your personality, what do you like about the company, how this company is something that you are actually looking for, where you see yourself in five/ten  years etc… In this stage you will have a very small insight about the company. Probably you wouldn’t get answers to some of your concrete questions. Everything will be on the high level, without concrete answers, but it seems that it is the way things work. In the short term, a lot of talk without actual meaning.Another thing that can be even worse than this is that you talk with the recruiter. He or she will just talk about that one company whose name they cannot tell you in this first stage, but the company is a leader in the software industry and a great employer, and they assure you this is the chance you shouldn’t miss.If you manage thru the first round interview, then you will probably be faced with the technical part of the interviewing process. Things are getting serious now. This part is usually conducted with someone who is a team leader or senior software engineer. And, from my experience, this is a time when you can have a pleasant chat with someone who comes from the same world, just like you. Both sides can benefit from this and even learn some things from each other. This interview usually contains some coding tasks, some questions about software development, design patterns, your opinions on some things in the software industry, etc… In this stage lies cannot be unnoticed, because you are talking about real things. Things mostly cannot be interpreted by the speaker like he wants. They are as they are. I mean, you cannot say that one design pattern is actually something else.If you have successfully passed previous parts, you can expect one more talk with the manager. Now comes the hardest thing. Why? Because we usually don’t have experience in negotiation because we code , right? On the other hand, managers here are way better than us because their job mainly consists of negotiations. Many of them will try to represent their company as something where you should be proud to work in because they are great employers with equal opportunities to everyone. In their words everything is ideal. But, as always the real truth is somewhere in the middle.Why do they lie or avoid telling the truth?This cannot be treated in one way and a deeper look at the whole situation should be taken.On the one hand, managers tend to think about their company like something that is partly or entirely their creation. If something is your creation, of course you will say it is the best, right? What do you think about the code you write? So, if we put things in this way, then the lie is not an intention. It is a lack of ability to see the wider picture. On the other hand, it could be that they do this intentionally because they think you will get into a trap, and when you realize that something was a lie, it is too late. You are already there in the middle of some project, accustomed with your environment and colleagues, and it is harder to leave then.How to see if something is wrong during your interview?Good approach is to pay attention to your interlocutor’s speech, voice and body language. It would be very strange if everything is ideal or close to being like that. If that is the case, that is the first sign something is wrong and you should ask some questions that they don’t expect at that moment. In any case, you are at an interview and not at some presentation when you are just sitting and listening. Be an active participant in your interview, not just someone who answers questions.Another thing, body language is equally, if not more important than speaking in terms of understanding what another person feels. Try to keep eye contact to see eye movements of your speaking partner. This can tell you more than you hear from them. Watch the position of their body. How they sit in the chair, position of arms, etc… All these signs can be helpful to you when you are making a final decision. A lot of good books are written on the subject of body language and you should definitely inform yourself about this topic.Of course, all of these things cannot be a guarantee that you can’t get into the trap of starting to work for a bad company, but at least it can increase the probability for you to see and recognize a lie."
    },
  
    {
      "title": "Design Patterns: Factory Method",
      "url": "/design-patterns-factory-method",
      "date": "2025-02-03",
      "tags": "csharp, cleancode, designpatterns, factorymethod",
      "content": "Let’s continue our series on design patterns with the Factory Method. Like the Builder or Singleton patterns we covered in previous posts, the Factory Method is also one of the creational patterns. It introduces a slightly more complex approach, offering a higher level of abstraction for object creation. Additionally, it helps decouple the object creation process from the rest of the application.It can be represented through the following components:  Abstract object , which represents the base class for the objects that we want to create  Concreate objects , classes that inherit the given base class  Creator , abstraction of the classes resposible for the object creation  Concreate creators, classes that inherit and implement given creator class  Client or Consumer side , parts of the application where we call objects creationBellow, we will show all these parts in one simple example.using System;// abstract objectabstract class Engine{    public abstract void Start();}// Concrete object, concrete Engine classesclass DieselEngine: Engine{    public override void Start()    {        Console.WriteLine(\"Starting diesel engine!\");    }}class PetrolEngine: Engine{    public override void Start()    {        Console.WriteLine(\"Starting petrol engine!\");    }}// Creatorabstract class EngineFactory{    public abstract Engine CreateEngine();}// Concrete Creatorsclass DieselEngineFactory : EngineFactory{    public override Engine CreateEngine()    {        return new DieselEngine();    }}class PetrolEngineFactory : EngineFactory{    public override Engine CreateEngine()    {        return new PetrolEngine();    }}// Client codeclass Program{    static void Main(string[] args)    {        EngineFactory factory;        // Let's assume user chooses the engine type at runtime.        Console.WriteLine(\"Enter the type of engine (diesel/petrol):\");        string choice = Console.ReadLine()?.ToLower();        if (choice == \"diesel\")        {            factory = new DieselEngineFactory();        }        else if (choice == \"petrol\")        {            factory = new PetrolEngineFactory();        }        else        {            Console.WriteLine(\"Invalid choice!\");            return;        }        Engine engine = factory.CreateEngine();        engine.Start();    }}In the example above, we can see the simple case where this pattern could be applied. Now, when we want to add a new engine type, we just need to extend existing logic with new engine type, without change of existing code resposible for Diesel or Petrol engines. Here we can see the flexibility of such approach, but of course, in some cases this can be the overhead. Examples of the overhead could be when we have the cases for simple object creation or when we know that extension of existing objects creation won’t happen in the future. In such cases, this pattern would be just an overengineering and not necessary at all."
    },
  
    {
      "title": "Keep Your Database In Sync With Application: Fluent Migrator",
      "url": "/keep-your-database-in-sync-with-application-fluent-migrator",
      "date": "2025-01-26",
      "tags": "csharp, database, migrations, entityframework",
      "content": "In this post, we continue to explore ways to free your application from being tightly bound to the Entity Framework environment. The primary goal is to offer an alternative solution that is not only more flexible and robust but also gives you, as a developer, greater control over database manipulation with less abstraction and complexity. Here, we introduce a library for database migrations, which serves as a natural extension to tools like Dapper and SqlKata.Fluent MigratorFluent Migrator is a library designed for managing database migrations, giving you complete control over the execution and how migrations are written. It offers greater flexibility compared to standard EF migrations, which are closely tied to EF entities and generated automatically, often accompanied by additional overhead, including extra snapshot files.In the code snippet below, you’ll find a simple migration class. This class includes two methods that override the base Migration class, allowing you to define your migration. This is all you need to create a migration.using FluentMigrator;[Migration(2025011801)]public class Mig2025011801Init : Migration{    public override void Up()    {        Create.Table(\"Company\")            .WithColumn(\"Id\").AsInt32().PrimaryKey().Identity()            .WithColumn(\"Name\").AsString(255).NotNullable()    }    public override void Down()    {        Delete.Table(\"Company\");    }}  Additionally, when starting the project, we need to configure FluentMigrator to locate the migration classes and define how they should be executed. This is demonstrated in the code snippet below.using FluentMigrator.Runner;using Microsoft.Extensions.DependencyInjection;class Program{    static void Main(string[] args)    {        var serviceProvider = CreateServices();        using (var scope = serviceProvider.CreateScope())        {            UpdateDatabase(scope.ServiceProvider);        }    }    private static IServiceProvider CreateServices()    {        return new ServiceCollection()            .AddFluentMigratorCore()            .ConfigureRunner(rb =&gt; rb                .AddSqlServer()                .WithGlobalConnectionString(\"conn string\")                .ScanIn(typeof(Mig2025011801Init).Assembly).For.Migrations())            .AddLogging(lb =&gt; lb.AddFluentMigratorConsole())            .BuildServiceProvider(false);    }    private static void UpdateDatabase(IServiceProvider serviceProvider)    {        var runner = serviceProvider.GetRequiredService&lt;IMigrationRunner&gt;();        runner.MigrateUp();    }}  ConclusionIn conclusion, let us show one table where we see simple comparison between FluentMigrator and EF migrations. This can help you to decide which migration library to use for your next or existing project.            Fluent Migrator      EF Migrations                  Schema migrations for databases with full control over structure      Built-in to EF for schema migrations tied to EF models              Independent of ORM (works with raw ADO.NET, Dapper, or others)      Closely integrated with Entity Framework              Requires writing migrations manually, which can be verbose but provides full control.      Migrations are auto-generated and customizable in C#.              Allows full control, suitable for existing schemas      Focused on Code First or Model First approaches              Explicitly define Down() methods for each migration. Provides precise control over rollback logic      Rollbacks involve reverting migrations using commands like Update-Database -TargetMigration              Integrates well into CI/CD pipelines as a standalone migration tool. Can be used independently of application deployment      Integrated into EF workflows, making deployment tied to EF-related commands. Often relies on the application’s context to execute migrations      "
    },
  
    {
      "title": "Dapper On Steroids: SqlKata",
      "url": "/dapper-on-steroids-sqlkata",
      "date": "2025-01-25",
      "tags": "csharp, sqlkata, dapper, entityframework",
      "content": "Dapper is a lightweight, high-performance ORM for .NET. It is widely used because of its simplicity and speed. Dapper in its essence provides simple mapping to POCO and works with raw queries minimizing the overhead. On the other hand it lacks of flexibility in terms of query writing, because we need to write queries like static strings. One simple example is shown in the code snippet below.using System;using System.Data.SqlClient;using Dapper;class Program{    static void Main(string[] args)    {        using (var connection = new SqlConnection(\"connection_string\"))        {            connection.Open();            string sql = \"SELECT * FROM Companies\";            var companies = connection.Query&lt;Company&gt;(sql);        }    }}With the lack of flexibility in query construction, we would be in temptation to go for Entity Framework or some other heavy weight ORM, but there is also a simple library (SqlKata) which provides a decent flexibility in query construction and also keeps a full control over the generated query and we don’t need to trade of the execution speed.The library itself is mostly based on Builder Design Pattern that is used for constructing queries. In the code snipet below is a simple example how to use the library.var connection = new SqlConnection(\"connection string example\");var compiler = new SqlServerCompiler();var db = new QueryFactory(connection, compiler);var query = db.Query(\"Companies\")    .Select(\"Id\", \"Name\")    .Where(\"IsActive\", true)    .OrderBy(\"Name\")    .Limit(10);The library also supports all other SQL comamnds, so it is worth to check it if you want to keep your query generation lighweight, simple and in your full control, what we cannot say for Entity Framework. Of course, this cannot be a full alternative to Entity Framework, but it can replace it in most cases."
    },
  
    {
      "title": "Design Patterns: Builder",
      "url": "/design-patterns-builder",
      "date": "2025-01-22",
      "tags": "builder, csharp, softwaredevelopment, designpatterns",
      "content": "This is also, like a Singleton, one of the creational design patterns. It provides the way of creating complex objects step by step by simple chaining and every particular step is independent of other steps.Let us dive into the real example of usage. For showing purpose we have created an example in C# which creates simple SQL queries using described pattern.using System;using System.Text;namespace BuilderPatternExample{    public interface ISqlQueryBuilder    {        ISqlQueryBuilder Select(string columns);        ISqlQueryBuilder From(string table);        ISqlQueryBuilder Where(string condition);        ISqlQueryBuilder OrderBy(string columns);        string Build();    }    public class SelectQueryBuilder : ISqlQueryBuilder    {        private readonly StringBuilder _queryBuilder;        public SelectQueryBuilder()        {            _queryBuilder = new StringBuilder();        }        public ISqlQueryBuilder Select(string columns)        {            _queryBuilder.Append($\"SELECT {columns} \");            return this;        }        public ISqlQueryBuilder From(string table)        {            _queryBuilder.Append($\"FROM {table} \");            return this;        }        public ISqlQueryBuilder Where(string condition)        {            _queryBuilder.Append($\"WHERE {condition} \");            return this;        }        public ISqlQueryBuilder OrderBy(string columns)        {            _queryBuilder.Append($\"ORDER BY {columns} \");            return this;        }        public string Build()        {            return _queryBuilder.ToString().Trim();        }    }        class Program    {        static void Main(string[] args)        {            ISqlQueryBuilder queryBuilder = new SelectQueryBuilder();            string query = queryBuilder                .Select(\"id, name, age\")                .From(\"Users\")                .Where(\"age &gt; 18\")                .OrderBy(\"name ASC\")                .Build();            Console.WriteLine(\"Generated SQL Query:\");            Console.WriteLine(query);        }    }}In this particular example we can see that we avoid to use hardcoded SQL strings and provide one flexible way of building the queries. Same example can be extended to other SQL commands. In the end, client that uses the builder interface does not need to care about the order of commands, or on spelling of SQL keywords.When to use it?  When constructing a complex object requires many steps.  To create object with lot of optional parameters.  When constructing objects with immutable states.  To improve code readability and reduce the complexity of the object creation logic.When not to use it?  When having simple objects with few properties.  High-performance systems with frequent object creation.  A singleton or a constant-like object.  If the codebase is unlikely to grow or change significantly.ConclusionThe Builder pattern is ideal for creating complex objects step-by-step, especially when they have many configurable parts or require different variations. It improves code readability, ensures consistency, and simplifies object construction by separating the build logic from the object itself. However, it’s best suited for scenarios where complexity justifies its use—avoid it for simple objects or straightforward creation processes."
    },
  
    {
      "title": "Make Git Log Great (Again): Merge vs Rebase",
      "url": "/make-git-log-great-again-merge-vs-rebase",
      "date": "2025-01-15",
      "tags": "softwaredevelopment, versioncontrol, git",
      "content": "A well-maintained Git log is more than just a record of commits—it’s a story of your project’s growth, collaboration, and problem-solving. But as projects scale and teams grow, Git logs can become cluttered, making it harder to trace changes, understand context, or troubleshoot issues.In this post, we’ll explore strategies to make your Git log more readable, structured, and useful—because a great Git log isn’t just good practice; it’s a competitive advantage.Simple MergingLet’s kick off with a simple merging strategy, the one we are all probably most familiar with. For simplification purposes, let’s assume we have one main branch that represents the current development branch. Every team member creates their own branch when they want to work on a specific feature and continues working on that feature branch until it is finished. Once it’s done, they merge their feature branch into the main branch, and all their work is integrated into the main branch. Then, they can move on to the next feature. Below is a small drawing that represents the described behavior.What Happens When a Feature Branch Takes Longer to Implement?Here comes the first problem: what if our feature branches are not short and need to be implemented over a longer period of time? In this case, we risk our feature branch becoming outdated compared to the main branch.We can solve this problem by more frequently merging changes from the main branch into our feature branch. This keeps our branch updated with the latest changes from the main branch and helps avoid the risk of encountering a lot of conflicts when we eventually merge the feature branch back into the main branch. A small illustration of this concept can be found in the image below.On one hand, we have reduced the likelihood of larger conflicts when merging our feature branch into the main branch. However, on the other hand, we are making our Git log harder to read and introducing tightly coupled commits, which makes reverting changes more challenging—and in real-world scenarios, almost impossible. The problem becomes even worse as the team grows and feature branches take longer to complete.Another Approach: Simple RebaseNow, let us take a look at the same example, but this time using rebasing instead of merging. This means that when we need to update the feature branch with the current main branch, we rebase the feature branch onto the current main. Similarly, when we want to update the current main branch with our feature branch, we rebase the main branch onto the rebased feature branch. Below is an image illustrating this example in contrast to the merging approach.Here, we can see that the Git log becomes much more readable and easier to track when features are integrated into the main branch. In this example, we have displayed just one feature branch and a simplified main branch for illustration purposes, but this approach can also be applied to much more complex scenarios.Can it be improved?Yes, we can further improve the example above by simply squashing the feature branch into a single commit before including its changes in the main branch. For illustration purposes, we will display only the last two steps.With this final step, we’ve streamlined our feature branches into a single commit in the Git log. This approach not only condenses the feature development into a neat, single entry, but also transforms the Git log into a clean, chronological timeline. By simplifying the development history, the log becomes much easier to follow, maintain, and understand—especially when navigating through complex projects. Moreover, with fewer commits to manage, it’s much simpler to identify changes, isolate specific updates, and, if needed, revert them with less risk of unintended consequences. This results in a more organized and manageable Git history, which ultimately benefits both individuals and teams working on the project."
    },
  
    {
      "title": "Book Reviews: Clean Code",
      "url": "/book-reviews-clean-code",
      "date": "2025-01-08",
      "tags": "books, cleancode, softwaredevelopment, designprinciples",
      "content": "Undoubtedly, one of the most popular books in software engineering, it teaches the fundamentals of software architecture, methods for organizing code, and is widely regarded as a must-read for any software developer. Written by Robert C. Martin, also known as “Uncle Bob,” the full title of the book is “Clean Code: A Handbook of Agile Software Craftsmanship”.Key TakeawaysThe book emphasizes a few important topics to pay attention to:      Readability: The code should be written in a meaningful manner that is easy to read and understand. It emphasizes the importance of simple, short, clear naming for variables, functions/methods, classes, and other structures for code organization (folders, namespaces, packages), as well as maintaining consistency in naming throughout the application. This also reduces the need to write comments in the code, as the code itself should be self-explanatory. Additionally, it’s important to avoid using global variables, as they often introduce unseen or difficult-to-track dependencies, making the code harder to maintain and debug.        Simplicity: Keep it simple and avoid the trap of overengineering to show how smart you are ☺Good code is the code that can be easily maintained.        Modularity: Code should be organized in smaller units easy to change and refactor. Also here important to mention is to make modules based on single responsibility priciple, meaning that one module/unit should not be resposible for more than one task. This principle should be upheld at all architectural levels, considering the appropriate granularity of each module. Granularity, in other words, refers to the abstraction level of a module/unit (such as a function, class, package/namespace, library, etc.).        Testability and Refactoring: These two topics are somehow related. In the process of writing the code that is easy to test, we are constantly refactoring it. Once when all tests are passed, we ensure that we can go with further refactoring if needed, because we have something that backs up the functionality and ensures it won’t be broken.  ConclusionAlthough there is much more to discuss regarding this book, it wouldn’t be suitable for a single blog post. That’s why we’ll keep it short and simple. One important thing to remember is that the book is not a set of rigid rules, but rather a collection of best practices for writing efficient and maintainable software. The main focus, after efficiency, is maintainability, since we, as developers (except for the lucky ones ☺), spend much more time reading old code than writing new one."
    },
  
    {
      "title": "Design Patterns: Singleton",
      "url": "/design-patterns-singleton",
      "date": "2025-01-01",
      "tags": "csharp, softwaredevelopment, designpatterns, singleton",
      "content": "Tyipically the first design pattern most people learn, often wrongly ☺ To give an introduction, we can say that singleton is one of the creational design patterns which ensures only one class instance with single point of access thru entire application.Because it is relatively simple to implement, the Singleton pattern is sometimes misapplied in situations where it is not the most suitable choice.When to use it?Here are the few examples of corrent usage of singleton:      Configuration Management Centralized configuration settings for consistent use thru entire application        Caching Maintaning  Single istance of cached objects for easy and fast acces        Logging Ensure unified mechanism to avoid duplication of log files, formats, etc        Global State Management  Centralized management of the state which is needed to be shared accross the application        Resource sharing  Thread pools, database connection, I/O operations  When not to use it?On the other hand, here are few examples on when  NOT to use it:      When you have multiple instances of the application by infrastructure design. Here you need to be careful because in most cases it won’t behave as expected, because every process will have its own instance.        When you can solve problem easy without overcomplicating. Strive to keep your design as simple as possible and avoid unnecessary complexity.        When by design you need stateless service.  Here singleton does more harm than help        When application needs to overwrite initialization parameters frequently. This is clear sign to not use it in this place.        High cuncerrency systems. Here, singleton instance can become bottleneck and actually be missused in order to keep it synced all the time.  Code ExampleHere, we will give a thread safe C# implementation of the pattern.public sealed class Singleton{    private static Singleton _instance;    private static readonly object _lock = new object();    private Singleton()    {        // initialization code    }    public static Singleton Instance    {        get        {            if (_instance == null)            {                lock (_lock)                {                    if (_instance == null)                    {                        _instance = new Singleton();                    }                }            }            return _instance;        }    }    public void Hello()    {        Console.WriteLine(\"Hello from singleton.\");    }}class Program{    static void Main(string[] args)    {        Singleton.Instance.Hello();    }}  \t\t"
    }
  
]
